<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>åœ£è¯æ ‘é­”æ³•ç…§ç‰‡ - æäº®å¢å¼ºç‰ˆ</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* èƒŒæ™¯æ”¹ä¸ºæ·±ç»¿è‰²æ¸å˜ï¼Œæå‡å±‚æ¬¡æ„Ÿ */
            background: radial-gradient(circle at center, #051a05 0%, #000 100%); 
            font-family: 'Microsoft YaHei', sans-serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute; top: 30px; left: 30px; color: #ffd700;
            pointer-events: none; z-index: 10; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
        }
        #video-input { 
            position: absolute; bottom: 20px; right: 20px; width: 150px; 
            border: 2px solid #d4af37; border-radius: 12px; transform: scaleX(-1);
            opacity: 0.5; z-index: 5; background: #000;
        }
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #1a331a 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #d4af37; z-index: 100; transition: opacity 0.8s;
        }
        .merry-text {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0);
            color: #fff; font-size: 60px; font-weight: bold; text-align: center;
            pointer-events: none; 
            text-shadow: 0 0 10px #ff0000, 0 0 30px #ffd700, 0 0 50px #ffd700;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 20; white-space: nowrap; opacity: 0;
        }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 24px; margin-bottom: 10px;">âœ¨ åœ£è¯é­”æ³•åŠ è½½ä¸­...</div>
    <p>è¯·å¼€å¯æ‘„åƒå¤´æƒé™ä»¥å¼€å¯äº’åŠ¨</p>
</div>

<div id="ui-layer">
    <h1 style="margin:0; font-size: 2.5em;">CHRISTMAS MAGIC</h1>
    <p>ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šå¬å”¤åœ£è¯æ ‘ä¸ç…§ç‰‡å¢™</p>
    <p>ğŸ‘Œ æåˆæŒ‡å°–ï¼šæŠ“å–å¹¶æ”¾å¤§ç…§ç‰‡</p>
</div>

<div id="merry-text" class="merry-text">å¯è¹ åœ£è¯å¿«ä¹!<br>Merry Christmas!</div>

<video id="video-input" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/** * é…ç½®åŒºï¼šåœ¨æ­¤å¤„æ·»åŠ ä½ çš„ç…§ç‰‡è·¯å¾„
 * å¯ä»¥æ˜¯ç›¸å¯¹è·¯å¾„å¦‚ 'img/1.jpg' æˆ–å®Œæ•´çš„ç½‘ç»œ URL
 */
const photoList = [
    'images/photo_v91mzp281ll.jpg',
    'images/photo_x92nk29sl01.jpg',
    'images/photo_y93mzp30m35.jpg',
    'images/20251218142429_34_124.jpg',
    'images/20251218142209_29_124.jpg',
    'imges/20251218142005_24_124.jpg',
    'imges/20251218141931_22_124.jpg'
];

let scene, camera, renderer, instancedMesh, photosGroup;
let currentState = 'closed';
let grabbedObject = null;
const PARTICLE_COUNT = 1000;
const dummy = new THREE.Object3D();
const merryDom = document.getElementById('merry-text');

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 25);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // å¼€å¯è‰²è°ƒæ˜ å°„ï¼Œè®©ç”»é¢æ›´äº®æ›´æŸ”å’Œ
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- å…‰ç…§å¢å¼º ---
    const ambient = new THREE.AmbientLight(0xffffff, 1.5); // æå‡åŸºç¡€ç¯å¢ƒå…‰
    scene.add(ambient);

    const topLight = new THREE.DirectionalLight(0xffffff, 1.2); // é¡¶éƒ¨é«˜å…‰
    topLight.position.set(5, 15, 10);
    scene.add(topLight);

    const pointLight = new THREE.PointLight(0xffd700, 1, 50); // ä¸­å¿ƒæš–å…‰
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ
    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    // æ”¹ç”¨ MeshPhongMaterial æå‡åå…‰æ•ˆæœ
    const material = new THREE.MeshPhongMaterial({ shininess: 80, specular: 0xffffff });
    instancedMesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);

    const particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ratio = i / PARTICLE_COUNT;
        const angle = ratio * Math.PI * 40;
        const radius = (1 - ratio) * 6;
        const treePos = new THREE.Vector3(Math.cos(angle)*radius, ratio*15 - 5, Math.sin(angle)*radius);
        const randPos = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*35, (Math.random()-0.5)*50);
        particles.push({ current: treePos.clone(), tree: treePos, rand: randPos });
        
        // æäº®é¢œè‰²
        const color = new THREE.Color().setHex([0x2e8b57, 0xffd700, 0xff4500][i % 3]);
        instancedMesh.setColorAt(i, color);
    }
    instancedMesh.userData.particles = particles;
    scene.add(instancedMesh);

    photosGroup = new THREE.Group();
    scene.add(photosGroup);

    // æ‰§è¡Œåå°åŠ è½½ç…§ç‰‡
    loadPhotos();
}

// ä¿®æ”¹åçš„åŠ è½½ç…§ç‰‡é€»è¾‘ï¼šæ·»åŠ ç›¸æ¡†
function loadPhotos() {
    const loader = new THREE.TextureLoader();
    const frameMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xffffff, 
        shininess: 100,
        specular: 0x444444
    });

    photoList.forEach((url, index) => {
        loader.load(url, (tex) => {
            // åˆ›å»ºä¸€ä¸ªç»„æ¥è£…è½½ç…§ç‰‡å’Œç›¸æ¡†
            const photoContainer = new THREE.Group();

            // 1. åˆ›å»ºç›¸æ¡† (æ¯”ç…§ç‰‡ç•¥å¤§)
            const frameGeometry = new THREE.PlaneGeometry(4.4, 5.9);
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            
            // 2. åˆ›å»ºç…§ç‰‡
            const photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 5.5),
                new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0,
                    depthWrite: false 
                })
            );
            photoMesh.position.z = 0.05; // è®©ç…§ç‰‡ç•¥å¾®æµ®åœ¨ç›¸æ¡†ä¸Šæ–¹

            photoContainer.add(frame);
            photoContainer.add(photoMesh);

            // 3. ä¼˜åŒ–é—´è·å¸ƒå±€ (é‡‡ç”¨åŠåœ†ç¯åˆ†å¸ƒ)
            const angle = (index / photoList.length) * Math.PI * 2;
            const radius = 22 + Math.random() * 5; // æ§åˆ¶åˆ†å¸ƒåŠå¾„
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                Math.random() * 15 - 2,
                Math.sin(angle) * 5 - 10 // æ§åˆ¶æ·±åº¦åˆ†å¸ƒ
            );
            
            const rotY = -angle + Math.PI; // è®©ç…§ç‰‡å¤§è‡´æœå‘ä¸­å¿ƒ
            
            photoContainer.position.copy(pos);
            photoContainer.rotation.y = rotY;
            
            // å­˜å‚¨åŸå§‹æ•°æ®ç”¨äºå¤åŸ
            photoContainer.userData.origPos = pos.clone();
            photoContainer.userData.origRotY = rotY;
            photoContainer.userData.isPhotoGroup = true;

            // ä¸ºäº†ä¿æŒé€æ˜åº¦æ§åˆ¶é€»è¾‘ï¼Œå°†æè´¨å¼•ç”¨æŒ‚è½½åˆ° Group ä¸Š
            photoContainer.material = photoMesh.material; 
            photoContainer.frameMaterial = frame.material;
            photoContainer.frameMaterial.transparent = true;
            photoContainer.frameMaterial.opacity = 0;

            photosGroup.add(photoContainer);
        });
    });
}

// ä¿®æ”¹åçš„è§†è§‰æ›´æ–°é€»è¾‘ï¼šæŸ¥çœ‹ç…§ç‰‡æ—¶éšè—ç¥ç¦è¯­
function updateVisuals() {
    const isClosed = currentState === 'closed';
    
    // æ ¸å¿ƒä¿®æ”¹ï¼šå¦‚æœæœ‰æŠ“å–çš„å¯¹è±¡ï¼Œæˆ–è€…å¤„äºå…³é—­çŠ¶æ€ï¼Œéšè—æ–‡å­—
    if (isClosed || grabbedObject) {
        merryDom.style.transform = "translate(-50%, -50%) scale(0)";
        merryDom.style.opacity = "0";
    } else {
        merryDom.style.transform = "translate(-50%, -50%) scale(1)";
        merryDom.style.opacity = "1";
    }

    // ç²’å­è¿‡æ¸¡
    instancedMesh.userData.particles.forEach((p) => {
        new TWEEN.Tween(p.current).to(isClosed ? p.tree : p.rand, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
    });

    // ç…§ç‰‡åŠç›¸æ¡†æ˜¾éš
    photosGroup.children.forEach(photoGroup => {
        const targetOpacity = isClosed ? 0 : (photoGroup === grabbedObject ? 1 : 0.7);
        new TWEEN.Tween(photoGroup.material).to({ opacity: targetOpacity }, 400).start();
        if(photoGroup.frameMaterial) {
            new TWEEN.Tween(photoGroup.frameMaterial).to({ opacity: targetOpacity }, 400).start();
        }
    });
}

function focusPhoto(photo) {
    // éšè—æ–‡å­—çš„é€»è¾‘å·²åœ¨ updateVisuals ä¸­è§¦å‘
    new TWEEN.Tween(photo.position).to({ x: 0, y: 5, z: 12 }, 500).easing(TWEEN.Easing.Cubic.Out).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: Math.PI * 2, z: 0 }, 500).start();
}

function releasePhoto(photo) {
    new TWEEN.Tween(photo.position).to({ 
        x: photo.userData.origPos.x, 
        y: photo.userData.origPos.y, 
        z: photo.userData.origPos.z 
    }, 400).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: photo.userData.origRotY, z: 0 }, 400).start();
}

async function initMediaPipe() {
    const video = document.getElementById('video-input');
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults((results) => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 800);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            const openDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            let newState = currentState;
            if (openDist < 0.25) newState = 'closed';
            else if (openDist > 0.4) newState = 'open';
            
            if(newState !== currentState) {
                currentState = newState;
                updateVisuals();
            }

            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            const handX = (lm[8].x - 0.5) * -45; 
            const handY = (0.5 - lm[8].y) * 30 + 5;

            if (pinchDist < 0.07 && currentState === 'open') {
                if (!grabbedObject) {
                    let closest = null;
                    let minDist = 15;
                    photosGroup.children.forEach(photo => {
                        const d = photo.position.distanceTo(new THREE.Vector3(handX, handY, photo.position.z));
                        if (d < minDist) { minDist = d; closest = photo; }
                    });
                    if (closest) { grabbedObject = closest; focusPhoto(grabbedObject); }
                }
            } else if (pinchDist > 0.12) {
                if (grabbedObject) { releasePhoto(grabbedObject); grabbedObject = null; updateVisuals(); }
            }

            camera.position.x += ((lm[0].x - 0.5) * -15 - camera.position.x) * 0.05;
            camera.lookAt(0, 5, 0);
        }
    });

    const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 640, height: 480
    });
    cameraUtils.start();
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    if (instancedMesh) {
        instancedMesh.userData.particles.forEach((p, i) => {
            dummy.position.copy(p.current);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        });
        instancedMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
}

// å¯åŠ¨
initThree();
initMediaPipe().catch(() => {
    document.querySelector('#loading p').innerText = "è¯·ç¡®ä¿æ‘„åƒå¤´å·²è¿æ¥å¹¶æˆæƒ";
});
animate();

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>åœ£è¯æ ‘é­”æ³•ç…§ç‰‡ - å¢å¼ºæ¸…æ™°ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #051a05 0%, #000 100%); font-family: 'Microsoft YaHei', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 30px; left: 30px; color: #ffd700; pointer-events: none; z-index: 10; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8); }
        #video-input { position: absolute; bottom: 20px; right: 20px; width: 150px; border: 2px solid #d4af37; border-radius: 12px; transform: scaleX(-1); opacity: 0.5; z-index: 5; background: #000; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #1a331a 0%, #000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #d4af37; z-index: 100; transition: opacity 0.8s; }
        .merry-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0); color: #fff; font-size: 60px; font-weight: bold; text-align: center; pointer-events: none; text-shadow: 0 0 10px #ff0000, 0 0 30px #ffd700, 0 0 50px #ffd700; transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 20; white-space: nowrap; opacity: 0; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 24px; margin-bottom: 10px;">âœ¨ åœ£è¯é­”æ³•åŠ è½½ä¸­...</div>
    <p>è¯·å¼€å¯æ‘„åƒå¤´æƒé™ä»¥å¼€å¯äº’åŠ¨</p>
</div>

<div id="ui-layer">
    <h1 style="margin:0; font-size: 2.5em;">CHRISTMAS MAGIC</h1>
    <p>ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šåˆå§‹åŒ–é­”æ³•</p>
    <p>ğŸ‘Œ æåˆæŒ‡å°–ï¼šæŠ“å–ç…§ç‰‡</p>
</div>

<div id="merry-text" class="merry-text">å¯è¹ åœ£è¯å¿«ä¹!<br>Merry Christmas!</div>

<video id="video-input" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const photoList = [
    'images/photo_v91mzp281ll.jpg',
    'images/photo_x92nk29sl01.jpg',
    'images/photo_y93mzp30m35.jpg',
    'images/20251218142429_34_124.jpg',
    'images/20251218142209_29_124.jpg',
    'images/20251218142005_24_124.jpg',
    'images/20251218141931_22_124.jpg'
];

let scene, camera, renderer, instancedMesh, photosGroup;
let currentState = 'closed';
let grabbedObject = null;
let hasShownBlessing = false; // è®°å½•ç¥ç¦è¯­æ˜¯å¦æ˜¾ç¤ºè¿‡
const PARTICLE_COUNT = 1000;
const dummy = new THREE.Object3D();
const merryDom = document.getElementById('merry-text');

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 25);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // æå‡æ¸…æ™°åº¦ï¼šä½¿ç”¨ç‰©ç†åƒç´ æ¯”
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.5));
    const topLight = new THREE.DirectionalLight(0xffffff, 1.2);
    topLight.position.set(5, 15, 10);
    scene.add(topLight);

    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const material = new THREE.MeshPhongMaterial({ shininess: 80, specular: 0xffffff });
    instancedMesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);

    const particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ratio = i / PARTICLE_COUNT;
        const angle = ratio * Math.PI * 40;
        const radius = (1 - ratio) * 6;
        const treePos = new THREE.Vector3(Math.cos(angle)*radius, ratio*15 - 5, Math.sin(angle)*radius);
        const randPos = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*35, (Math.random()-0.5)*50);
        particles.push({ current: treePos.clone(), tree: treePos, rand: randPos });
        instancedMesh.setColorAt(i, new THREE.Color().setHex([0x2e8b57, 0xffd700, 0xff4500][i % 3]));
    }
    instancedMesh.userData.particles = particles;
    scene.add(instancedMesh);

    photosGroup = new THREE.Group();
    scene.add(photosGroup);
    loadPhotos();
}

function loadPhotos() {
    const loader = new THREE.TextureLoader();
    const frameMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 100 });

    photoList.forEach((url, index) => {
        loader.load(url, (tex) => {
            // æå‡çº¹ç†æ¸…æ™°åº¦å…³é”®è®¾ç½®
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            tex.minFilter = THREE.LinearMipmapLinearFilter;
            tex.magFilter = THREE.LinearFilter;

            const group = new THREE.Group();
            
            // ç…§ç‰‡
            const photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 5.5),
                new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true, opacity: 0 })
            );
            
            // ç›¸æ¡†
            const frameMesh = new THREE.Mesh(new THREE.PlaneGeometry(4.4, 5.9), frameMat.clone());
            frameMesh.position.z = -0.01;
            frameMesh.material.transparent = true;
            frameMesh.material.opacity = 0;

            group.add(photoMesh);
            group.add(frameMesh);

            // é—´è·ä¼˜åŒ–ï¼šå¤§åœ†ç¯å¸ƒå±€
            const angle = (index / photoList.length) * Math.PI * 2;
            const radius = 22;
            const pos = new THREE.Vector3(Math.cos(angle)*radius, Math.random()*12 - 2, Math.sin(angle)*8 - 5);
            group.position.copy(pos);
            group.rotation.y = -angle + Math.PI/2;

            group.userData.origPos = pos.clone();
            group.userData.origRotY = group.rotation.y;
            group.photoMat = photoMesh.material;
            group.frameMat = frameMesh.material;

            photosGroup.add(group);
        });
    });
}

function updateVisuals() {
    const isClosed = currentState === 'closed';
    
    // ç¥ç¦è¯­æ˜¾ç¤ºé€»è¾‘ï¼šä»…å½“ç¬¬ä¸€æ¬¡æ‰“å¼€ä¸”æœªè¢«æŠ“å–æ—¶æ˜¾ç¤º
    if (!isClosed && !hasShownBlessing && !grabbedObject) {
        merryDom.style.transform = "translate(-50%, -50%) scale(1)";
        merryDom.style.opacity = "1";
    } else {
        // ä¸€æ—¦éœ€è¦éšè—ï¼ˆå…³é—­æˆ–æŠ“å–ï¼‰ï¼Œåˆ™æ ‡è®°ä¸ºå·²æ˜¾ç¤ºè¿‡ï¼Œä»¥åä¸å†è‡ªåŠ¨å‡ºç°
        if (merryDom.style.opacity === "1") {
            hasShownBlessing = true;
        }
        merryDom.style.transform = "translate(-50%, -50%) scale(0)";
        merryDom.style.opacity = "0";
    }

    instancedMesh.userData.particles.forEach((p) => {
        new TWEEN.Tween(p.current).to(isClosed ? p.tree : p.rand, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
    });

    photosGroup.children.forEach(group => {
        const targetOpacity = isClosed ? 0 : (group === grabbedObject ? 1 : 0.7);
        new TWEEN.Tween(group.photoMat).to({ opacity: targetOpacity }, 400).start();
        new TWEEN.Tween(group.frameMat).to({ opacity: targetOpacity }, 400).start();
    });
}

function focusPhoto(photo) {
    new TWEEN.Tween(photo.position).to({ x: 0, y: 5, z: 12 }, 500).easing(TWEEN.Easing.Cubic.Out).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: Math.PI * 2, z: 0 }, 500).start();
}

function releasePhoto(photo) {
    new TWEEN.Tween(photo.position).to({ x: photo.userData.origPos.x, y: photo.userData.origPos.y, z: photo.userData.origPos.z }, 400).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: photo.userData.origRotY, z: 0 }, 400).start();
}

async function initMediaPipe() {
    const video = document.getElementById('video-input');
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

    hands.onResults((results) => {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 800);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const openDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            
            let newState = currentState;
            if (openDist < 0.25) newState = 'closed';
            else if (openDist > 0.4) newState = 'open';
            
            if(newState !== currentState) {
                currentState = newState;
                updateVisuals();
            }

            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            const handX = (lm[8].x - 0.5) * -45; 
            const handY = (0.5 - lm[8].y) * 30 + 5;

            if (pinchDist < 0.07 && currentState === 'open') {
                if (!grabbedObject) {
                    let closest = null, minDist = 15;
                    photosGroup.children.forEach(photo => {
                        const d = photo.position.distanceTo(new THREE.Vector3(handX, handY, photo.position.z));
                        if (d < minDist) { minDist = d; closest = photo; }
                    });
                    if (closest) { 
                        grabbedObject = closest; 
                        focusPhoto(grabbedObject); 
                        updateVisuals(); // æŠ“å–æ—¶è§¦å‘éšè—
                    }
                }
            } else if (pinchDist > 0.12 && grabbedObject) {
                releasePhoto(grabbedObject); 
                grabbedObject = null; 
                updateVisuals(); 
            }
            camera.position.x += ((lm[0].x - 0.5) * -15 - camera.position.x) * 0.05;
            camera.lookAt(0, 5, 0);
        }
    });

    const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({ image: video }); }, width: 640, height: 480 });
    cameraUtils.start();
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    if (instancedMesh) {
        instancedMesh.userData.particles.forEach((p, i) => {
            dummy.position.copy(p.current);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        });
        instancedMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
}

initThree();
initMediaPipe().catch(() => { document.querySelector('#loading p').innerText = "è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™"; });
animate();

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>åœ£è¯æ ‘é­”æ³•ç…§ç‰‡ - å¢å¼ºæ¸…æ™°ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #051a05 0%, #000 100%); font-family: 'Microsoft YaHei', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-layer { position: absolute; top: 30px; left: 30px; color: #ffd700; pointer-events: none; z-index: 10; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8); }
        #video-input { position: absolute; bottom: 20px; right: 20px; width: 150px; border: 2px solid #d4af37; border-radius: 12px; transform: scaleX(-1); opacity: 0.5; z-index: 5; background: #000; }
        #loading { position: fixed; inset: 0; background: radial-gradient(circle, #1a331a 0%, #000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #d4af37; z-index: 100; transition: opacity 0.8s; }
        .merry-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0); color: #fff; font-size: 60px; font-weight: bold; text-align: center; pointer-events: none; text-shadow: 0 0 10px #ff0000, 0 0 30px #ffd700, 0 0 50px #ffd700; transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 20; white-space: nowrap; opacity: 0; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 24px; margin-bottom: 10px;">âœ¨ åœ£è¯é­”æ³•åŠ è½½ä¸­...</div>
    <p>è¯·å¼€å¯æ‘„åƒå¤´æƒé™ä»¥å¼€å¯äº’åŠ¨</p>
</div>

<div id="ui-layer">
    <h1 style="margin:0; font-size: 2.5em;">CHRISTMAS MAGIC</h1>
    <p>ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šåˆå§‹åŒ–é­”æ³•</p>
    <p>ğŸ‘Œ æåˆæŒ‡å°–ï¼šæŠ“å–ç…§ç‰‡</p>
</div>

<div id="merry-text" class="merry-text">å¯è¹ åœ£è¯å¿«ä¹!<br>Merry Christmas!</div>

<video id="video-input" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const photoList = [
    'images/photo_v91mzp281ll.jpg',
    'images/photo_x92nk29sl01.jpg',
    'images/photo_y93mzp30m35.jpg',
    'images/20251218141918_22_124.jpg',
    'images/20251218142005_24_124.jpg',
    'images/20251218142209_29_124.jpg',
    'images/20251218142336_30_124.jpg',
    'images/20251218142340_31_124.jpg',
    'images/20251218142414_33_124.jpg',
    'images/20251218142429_34_124.jpg'
];

let scene, camera, renderer, instancedMesh, photosGroup;
let currentState = 'closed';
let grabbedObject = null;
let hasShownBlessing = false;
let blessingDismissed = false;
const PARTICLE_COUNT = 1000;
const dummy = new THREE.Object3D();
const merryDom = document.getElementById('merry-text');

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 25);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // æå‡æ¸…æ™°åº¦ï¼šä½¿ç”¨ç‰©ç†åƒç´ æ¯”
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ğŸ¬ ç”µå½±æ„Ÿå…‰ç…§
    scene.add(new THREE.AmbientLight(0x404040, 1.2));
    const moonLight = new THREE.DirectionalLight(0xb0c4de, 1.5);
    moonLight.position.set(10, 20, 15);
    scene.add(moonLight);
    const warmLight = new THREE.PointLight(0xffa500, 1.2, 60);
    warmLight.position.set(0, -2, 10);
    scene.add(warmLight);

    // ğŸ„ ç”µå½±æ„Ÿåœ£è¯æ ‘ - çƒå½¢ç²’å­
    const geometry = new THREE.SphereGeometry(0.12, 16, 16);
    const material = new THREE.MeshStandardMaterial({ 
        metalness: 0.6,
        roughness: 0.3,
        emissive: 0xffd700,
        emissiveIntensity: 0.4
    });
    instancedMesh = new THREE.InstancedMesh(geometry, material, PARTICLE_COUNT);

    const particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ratio = i / PARTICLE_COUNT;
        const angle = ratio * Math.PI * 40;
        const radius = (1 - ratio) * 6;
        const treePos = new THREE.Vector3(Math.cos(angle)*radius, ratio*15 - 5, Math.sin(angle)*radius);
        const randPos = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*35, (Math.random()-0.5)*50);
        particles.push({ current: treePos.clone(), tree: treePos, rand: randPos });
        const colors = [new THREE.Color(0x2d5016), new THREE.Color(0xd4af37), new THREE.Color(0xff6b35)];
        instancedMesh.setColorAt(i, colors[i % 3]);
    }
    instancedMesh.userData.particles = particles;
    scene.add(instancedMesh);

    photosGroup = new THREE.Group();
    scene.add(photosGroup);
    loadPhotos();
}

function loadPhotos() {
    const loader = new THREE.TextureLoader();

    photoList.forEach((url, index) => {
        loader.load(url, (tex) => {
            // ğŸ”§ æœ€å¤§åŒ–ç…§ç‰‡æ¸…æ™°åº¦
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = false;
            tex.colorSpace = THREE.SRGBColorSpace;

            const group = new THREE.Group();
            
            // ğŸ“¸ ç…§ç‰‡ - å¢å¤§å°ºå¯¸æé«˜æ¸…æ™°åº¦
            const photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(5.5, 7.5),
                new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0,
                    depthWrite: true
                })
            );
            
            // ğŸ–¼ï¸ ç™½è‰²ç›¸æ¡† - åŒ¹é…æ›´å¤§çš„ç…§ç‰‡
            const outerFrame = new THREE.Mesh(
                new THREE.BoxGeometry(6.2, 8.2, 0.15),
                new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.4, transparent: true, opacity: 0 })
            );
            outerFrame.position.z = -0.1;
            
            const innerFrame = new THREE.Mesh(
                new THREE.PlaneGeometry(5.8, 7.8),
                new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.7, transparent: true, opacity: 0 })
            );
            innerFrame.position.z = -0.05;

            group.add(photoMesh);
            group.add(outerFrame);
            group.add(innerFrame);

            // é—´è·ä¼˜åŒ–ï¼šå¤§åœ†ç¯å¸ƒå±€
            const angle = (index / photoList.length) * Math.PI * 2;
            const radius = 22;
            const pos = new THREE.Vector3(Math.cos(angle)*radius, Math.random()*12 - 2, Math.sin(angle)*8 - 5);
            group.position.copy(pos);
            group.rotation.y = -angle + Math.PI/2;

            group.userData.origPos = pos.clone();
            group.userData.origRotY = group.rotation.y;
            group.photoMat = photoMesh.material;
            group.frameMats = [outerFrame.material, innerFrame.material];

            photosGroup.add(group);
        });
    });
}

function updateVisuals() {
    const isClosed = currentState === 'closed';
    
    // ğŸ¯ ç¥ç¦è¯­é€»è¾‘ï¼šä»…ç¬¬ä¸€æ¬¡å¼ å¼€æ‰‹æŒæ—¶æ˜¾ç¤ºï¼Œæåˆç…§ç‰‡æˆ–å…³é—­åæ°¸ä¹…æ¶ˆå¤±
    if (!isClosed && !grabbedObject && !hasShownBlessing) {
        // ç¬¬ä¸€æ¬¡æ‰“å¼€æ—¶æ˜¾ç¤ºç¥ç¦è¯­
        merryDom.style.transform = "translate(-50%, -50%) scale(1)";
        merryDom.style.opacity = "1";
        hasShownBlessing = true;
    } else if ((isClosed || grabbedObject) && hasShownBlessing && !blessingDismissed) {
        // æåˆç…§ç‰‡æˆ–å…³é—­æ‰‹æŒæ—¶æ°¸ä¹…éšè—
        merryDom.style.transform = "translate(-50%, -50%) scale(0)";
        merryDom.style.opacity = "0";
        blessingDismissed = true;
    }

    instancedMesh.userData.particles.forEach((p) => {
        new TWEEN.Tween(p.current).to(isClosed ? p.tree : p.rand, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
    });

    photosGroup.children.forEach(group => {
        // ğŸ”§ å…³é—­çŠ¶æ€æ—¶å®Œå…¨éšè—ï¼Œé¿å…èƒŒåé¢œè‰²å¹²æ‰°
        if (isClosed) {
            group.visible = false;
            group.photoMat.opacity = 0;
            group.frameMats.forEach(mat => mat.opacity = 0);
        } else {
            group.visible = true;
            const targetOpacity = (group === grabbedObject ? 1 : 0.85);
            new TWEEN.Tween(group.photoMat).to({ opacity: targetOpacity }, 400).start();
            group.frameMats.forEach(mat => {
                new TWEEN.Tween(mat).to({ opacity: targetOpacity }, 400).start();
            });
        }
    });
}

function focusPhoto(photo) {
    new TWEEN.Tween(photo.position).to({ x: 0, y: 5, z: 12 }, 500).easing(TWEEN.Easing.Cubic.Out).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: Math.PI * 2, z: 0 }, 500).start();
}

function releasePhoto(photo) {
    new TWEEN.Tween(photo.position).to({ x: photo.userData.origPos.x, y: photo.userData.origPos.y, z: photo.userData.origPos.z }, 400).start();
    new TWEEN.Tween(photo.rotation).to({ x: 0, y: photo.userData.origRotY, z: 0 }, 400).start();
}

async function initMediaPipe() {
    const video = document.getElementById('video-input');
    const loadingEl = document.getElementById('loading');
    
    // 5ç§’è¶…æ—¶æœºåˆ¶
    const timeoutId = setTimeout(() => {
        console.log('â±ï¸ è¶…æ—¶ï¼šè‡ªåŠ¨è¿›å…¥åœºæ™¯');
        if (loadingEl) {
            loadingEl.style.opacity = '0';
            setTimeout(() => { loadingEl.style.display = 'none'; }, 800);
        }
    }, 5000);
    
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

    hands.onResults((results) => {
        clearTimeout(timeoutId);
        loadingEl.style.opacity = '0';
        setTimeout(() => { loadingEl.style.display = 'none'; }, 800);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const openDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
            
            let newState = currentState;
            if (openDist < 0.25) newState = 'closed';
            else if (openDist > 0.4) newState = 'open';
            
            if(newState !== currentState) {
                currentState = newState;
                updateVisuals();
            }

            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            const handX = (lm[8].x - 0.5) * -45; 
            const handY = (0.5 - lm[8].y) * 30 + 5;

            if (pinchDist < 0.07 && currentState === 'open') {
                if (!grabbedObject) {
                    let closest = null, minDist = 15;
                    photosGroup.children.forEach(photo => {
                        const d = photo.position.distanceTo(new THREE.Vector3(handX, handY, photo.position.z));
                        if (d < minDist) { minDist = d; closest = photo; }
                    });
                    if (closest) { 
                        grabbedObject = closest; 
                        focusPhoto(grabbedObject); 
                        updateVisuals(); // æŠ“å–æ—¶è§¦å‘éšè—
                    }
                }
            } else if (pinchDist > 0.12 && grabbedObject) {
                releasePhoto(grabbedObject); 
                grabbedObject = null; 
                updateVisuals(); 
            }
            camera.position.x += ((lm[0].x - 0.5) * -15 - camera.position.x) * 0.05;
            camera.lookAt(0, 5, 0);
        }
    });

    const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({ image: video }); }, width: 640, height: 480 });
    cameraUtils.start();
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    if (instancedMesh) {
        instancedMesh.userData.particles.forEach((p, i) => {
            dummy.position.copy(p.current);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
        });
        instancedMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
}

initThree();
initMediaPipe().catch(() => { document.querySelector('#loading p').innerText = "è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™"; });
animate();

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>